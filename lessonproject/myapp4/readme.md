*.\venv\Scripts\Activate.ps1*

*python manage.py startapp myapp4*

в settings добавьте приложение в константу со списком приложений

## Создаём класс формы
## Представление для формы 
использeем представление для перевода формы из класса в
видимый пользователем HTML, а также для обработки данных, которые
пользователь введёт в форму и отправит на сервер.
Для вывода формы по GET запросу и обработки данных по POST запросу в Django
views.py

## Прописываем url
В шаблоне user_form.html мы можем вывести нашу форму с помощью тега {{ form }}.
Также можно добавить кнопку Submit для отправки формы. Но ничего этого не
получится, если пользователь не имеет доступа к форме. Переходим в urls.py
проекта и подключаем новое приложение

from django.contrib import admin
from django.urls import path, include

А теперь прописываем маршрут для связи представления с url-адресом. Для этого
создаём urls.py внутри каталога приложения

from django.urls import path
from .views import user_form
urlpatterns = [
path('user/add/', user_form, name='user_form'),
]

Форма будет доступна по адресу http://127.0.0.1:8000/les4/user/add/ 
Остался финальный шаг.

## Отрисовка шаблона
Создадим каталог templates внутри приложения, а в нём
каталог с именем приложения. В нашем случае каталог myapp4/+
Файл base.html в каталоге templates проекта
Файл user_form.html в первой итерации. Переходим по адресу
http://127.0.0.1:8000/les4/user/add/ и смотрим на содержимое страницы. Обычно
клавиша F12 для доступа к коду. В нашем случае получилась следующая страница:
<!DOCTYPE html>
<html lang="ru"><head>
<meta charset="UTF-8">
<title>Формы</title>
</head>
<body wfd-invisible="true">
<label for="id_name">Name:</label>
<input type="text" name="name" maxlength="50" required=""
id="id_name">
<label for="id_email">Email:</label>
<input type="email" name="email" required="" id="id_email">
<label for="id_age">Age:</label>
<input type="number" name="age" min="0" max="120" required=""
id="id_age">
</body>
</html>
Класс UserForm был преобразован в набор полей label и input. Но тег form и кнопка
отправки отсутствуют. За их добавление, а также за шифрование данных отвечает
разработчиk

## Доработка шаблона

Чтобы мы действительно увидели форму ввода, внесём правки в шаблон
user_form.html
{% extends 'base.html' %}
{% block content %}
<form action="" method="post">
{% csrf_token %}
{{ form }}
<input type="submit" value="Отправить">
</form>
{% endblock %}

Мы добавили тег формы указав что при нажатии кнопки отправить нужно
использовать тот же url адрес для отправки данных и метод POST для пересылки.
Так же был добавлен тег csrf_token. Он обеспечивает защиту данных формы от
изменений злоумышленниками. Так называемая защита от CSRF атак.
Кроме того вручную добавлена кнопка отправки и закрывающий тег формы.
🔥 Важно! Четыре добавленные строки являются обязательными для
правильного отображения любой формы через шаблоны Django.
Подведём предварительный итог. Для работы с формами необходимо создать класс
формы в файле forms.py. Далее создаётся представление, которое отправялет
экземпляр формы в шаблон. Сам шаблон должен отрисовать html теги формы и
передать csrf_token и экземпляр формы. При этом стоит помнить про настройку
маршрутов.


## Поля и виджеты форм

Разберемся подробнее в том какие поля мы можем создавать внутри класса формы.
По сути каждое поле — это экземпляр класс <Name>Field из модуля forms, где
<Name> - имя класса поля.

## Поля форм

Перечислим некоторые из наиболее популярных классов Field в Django:
● CharField — используется для создания текстовых полей, таких как имя,
фамилия, электронная почта и т.д.
● EmailField — используется для создания поля электронной почты.
● IntegerField — используется для создания поля для ввода целых чисел.
● FloatField — используется для создания поля для ввода чисел с плавающей
точкой.
● BooleanField — используется для создания поля флажка.
● DateField — используется для создания поля даты.
● DateTimeField — используется для создания поля даты и времени.
● FileField — используется для создания поля для загрузки файла.
● ImageField — используется для создания поля для загрузки изображения.
● ChoiceField — используется для создания выпадающего списка с выбором
одного из нескольких вариантов.
Быстрее всего разобраться в различиях полей получится на примере. Создадим
форму для демонстрации разнообразия полей в файле *forms.py*


## Представление

В views.py допишем новое представление

## Маршрут
В urls.py допишем новый маршрут
Теперь по адресу http://127.0.0.1:8000/les4/forms/ мы можем увидеть нашу форму.

## Шаблон
Финальный штрих — добавление шаблона many_fields_form.html
В отличии от прошлого шаблона был добавлен вызов метода as_p через точку после
переменной form. Так мы отрисовываем html файл с выводом каждого поля формы
как отдельный абзац.

## Виджеты форм

В Django для работы с формами используются виджеты, которые определяют
внешний вид и поведение полей формы на странице. В Django предусмотрены
встроенные виджеты, такие как TextInput, Select, CheckboxInput и др., которые
можно использовать для создания различных типов полей формы.
Вот некоторые из наиболее популярных классов виджетов в Django:
● TextInput — используется для создания текстового поля ввода.
● EmailInput — используется для создания поля ввода электронной почты.
● PasswordInput — используется для создания поля ввода пароля.
● NumberInput — используется для создания поля ввода чисел.
● CheckboxInput — используется для создания флажка.
● DateInput — используется для создания поля ввода даты.
● DateTimeInput — используется для создания поля ввода даты и времени.
● FileInput — используется для создания поля загрузки файла.
● Select — используется для создания выпадающего списка с выбором одного
из нескольких вариантов.
● RadioSelect — используется для создания списка радиокнопок.
● Textarea — используется для создания многострочного текстового поля ввода.

Доработаем пример формы из прошлого раздела, Создадим форму аналогичную
*ManyFieldsForm*, но добавим в неё виджеты.


## Ручное изменение типа поля

Если возникают ситуации, когда отрисовку нужно
изменить, используются виджеты. Они позволяют заменить один вид на другой,
например обычное поле ввода на текстовую зону (textarea). Но бывают ситуации,
когда подобного недостаточно. Например в нашем примере даты приходится
вводить вручную. Большинство браузеров могут облегчить задачу. Изменим поле с
днём рождения на следующую строку
birthdate = forms.DateField(initial=datetime.date.today,
widget=forms.DateInput(attrs={'class': 'form-control', 'type':
'date'}))

## Обработка данных форм

Если мы воспользуемся формой из примера выше и попробуем ввести неверные
данные, Django автоматически сообщит об этом. Встроенные фильтры не дадут
пройти проверку правильности, метод form.is_valid() вернёт ложь. Однако
встроенных проверок может быть недостаточно.

## Пользовательская валидация данных с помощью метода clean()

Мы можем прописать свои методы, которые начинаются со слова clean_ и далее
указать имя поля. Такой метод будет применяться для дополнительной проверки
поля на корректность. Рассмотри пример формы UserForm из начала занятия, но
добавим пару своих проверок

## Сохранение формы в базу данных
После того как форма заполнена пользователем, отправлена Django, проверена и
прошла валидацию данные можно использовать. Обычное использование -
сохранение в базу данных.
## Модель данных
Начнём с создания модели.Для этого в файле myapp4/models.py пропишем
следующий код

### Перед тем как продолжить создадим и применим миграции:
python manage.py makemigrations myapp4
python manage.py migrate

## Представление

Доработаем представление из начала урока, чтобы оно сохраняло пользователя в
базу данных.

## Шаблон

Дополнительно в код представления добавлена переменная message, которая
принимает различные значения в зависимости от этапа обработки данных. Для её
отображения необходимо поправить шаблон user_form.html.

## Маршрут
Финальный этап — подключить представление обработчик, тем самым соединив
между собой модель и форму внутри представления.
Для проверки работы перейдём по адресу http://127.0.0.1:8000/les4/user/

## Сохранение изображений (файлов)
💡 Внимание! Аналогично можно сохранять любые файлы, а не только
картинки. 
Для этого заменяем ImageFied на FileField.
необходимо создать форму, которая будет содержать поле
ImageField, а также представление, которое будет обрабатывать данные формы и
сохранять загруженное изображение

## Форма forms.py
class ImageForm(forms.Form):
image = forms.ImageField()

## Настройка settings.py
Теперь позаботимся о том, чтобы Django создал каталог для наших изображений.
Перейдём в settings.py и пропишем следующие пару констант:
...
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media

## Представление views.py
Далее создадим представление:upload_image

Если поступил POST запрос, форма заполняется не только из request.POST, но и из
request.FILES. Там содержится наше изображение. Если проверка формы успешно
завершены, выполняем три действия:
1. Сохраняем изображение в переменной image
2. Создаём экземпляр класса FileSystemStorage для работы с файлами силами
Django
3. Просим экземпляр fs сохранить изображение. Метод save принимает имя
файла и сам файл

## Маршрут urls.py
Пропишем представление в списке маршрутов: path('upload/', upload_image, name='upload_image'),

## Шаблон templates/myapp4
Финальный этап - создать шаблон upload_image.html:
 Чтобы форма отправляла файлы необходимо в теге форм
прописать enctype="multipart/form-data". Без этого мы не получим доступ к
файлам.